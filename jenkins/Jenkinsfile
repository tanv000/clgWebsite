// -----------------------------------------------------------------------------
// Jenkins Pipeline for CI/CD of abc-college-web-app
// -----------------------------------------------------------------------------
pipeline {
    agent any

    environment {
        // AWS ECR Settings 
        AWS_REGION      = 'ap-south-1'
        AWS_ACCOUNT_ID  = '708972351530'
        ECR_REPOSITORY  = 'abc-college-web-app'
        IMAGE_TAG       = "latest"
        FULL_IMAGE_NAME = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}"

        // EC2 Host Settings 
        // ðŸ’¡ CRITICAL FIX: The host address is now dynamically set as DNS.
        WEB_APP_HOST_DNS = '' // Will be set dynamically after Terraform applies.
        WEB_APP_HOST_USER = 'ec2-user'
        // Credential ID for the SSH Key stored in Jenkins (Username with private key)
        WEB_APP_HOST_SSH_CREDENTIAL_ID = 'WEB_APP_HOST_SSH' 
    }

    stages {
        stage('SCM Checkout') {
            steps {
                echo 'Cloning repository...'
                checkout scm 
            }
        }

        stage('Destroy Previous Infrastructure (Local State Workaround)') {
            steps { 
                dir('terraform') { 
                    // ðŸ›‘ FIX: Use credentials for terraform destroy as well
                    withCredentials([
                        usernamePassword(
                            credentialsId: 'AWS_ECR_CREDENTIALS', 
                            usernameVariable: 'AWS_ACCESS_KEY_ID', 
                            passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                        )
                    ]) {
                        bat 'echo "Attempting to destroy old infrastructure..."'
                        // Use '|| true' to allow the pipeline to continue if destroy fails (e.g., first run)
                        bat 'terraform destroy -auto-approve -lock=false || true' 
                        // Delete the state file from the correct subdirectory
                        bat 'del /f /q .\\terraform.tfstate || true' 
                        bat 'echo "Cleanup attempt complete."'
                    }
                }
            }
        }

        stage('Build & Test (Optional)') {
            steps {
                bat 'echo "Skipping formal build/test for this project"'
            }
        }

        stage('Apply Infrastructure (Terraform)') {
            steps {
                dir('terraform') { 
                    // ðŸ›‘ FIX: Use credentials for terraform init/apply
                    withCredentials([
                        usernamePassword(
                            credentialsId: 'AWS_ECR_CREDENTIALS', 
                            usernameVariable: 'AWS_ACCESS_KEY_ID', 
                            passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                        )
                    ]) {
                        script {
                            bat 'echo "Initializing Terraform"'
                            bat 'terraform init' 
                            
                            bat 'echo "Applying Infrastructure"'
                            bat 'terraform apply -auto-approve'

                            // Get the Public DNS from Terraform output
                            def publicDns = sh(
                                script: "terraform output -raw web_app_public_dns", 
                                returnStdout: true
                            ).trim()
                            
                            // Set the environment variable for the later deployment stage
                            env.WEB_APP_HOST_DNS = publicDns
                            
                            echo "EC2 Host DNS is now dynamically set to: ${env.WEB_APP_HOST_DNS}"
                        }
                    }
                }
            }
        }

        stage('Docker Build & Push') {
            steps {
                script {
                    withCredentials([
                        usernamePassword(
                            credentialsId: 'AWS_ECR_CREDENTIALS', 
                            usernameVariable: 'AWS_ACCESS_KEY_ID', 
                            passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                        )
                    ]) {
                        
                        // 1. Authenticate Docker with ECR
                        echo 'Authenticating Docker with ECR...'
                        bat "aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

                        // 2. Build the Docker Image
                        echo "Building Docker image: ${FULL_IMAGE_NAME}"
                        bat "docker build -t ${ECR_REPOSITORY} ."
                        
                        // 3. Tag the image for ECR
                        echo "Tagging image..."
                        bat "docker tag ${ECR_REPOSITORY}:latest ${FULL_IMAGE_NAME}"

                        // 4. Push the image to ECR
                        echo "Pushing image to ECR..."
                        bat "docker push ${FULL_IMAGE_NAME}"
                    }
                }
            }
        }
        
        stage('Deploy to EC2') {
            steps {
                // ðŸ’¡ Use the dynamically set DNS
                echo "Deploying to EC2 host: ${env.WEB_APP_HOST_DNS}"

                // 1. Create the deploy.sh script locally
                script {
                    writeFile file: 'deploy.sh', text: """#!/bin/bash
# FIX: Relying on fixed environment PATH and attached IAM Role
IMAGE_TAG="\$1" 
IMAGE_REPO_URL="${env.AWS_ACCOUNT_ID}.dkr.ecr.${env.AWS_REGION}.amazonaws.com/${env.ECR_REPOSITORY}"

# ðŸ›‘ CRITICAL FIX: Correctly pipes the password to docker login.
aws ecr get-login-password --region ${env.AWS_REGION} | docker login --username AWS --password-stdin \$IMAGE_REPO_URL

# Stop and remove the old container
docker stop web-app-container || true
docker rm web-app-container || true

# Pull the latest image from ECR
docker pull \$IMAGE_REPO_URL:\$IMAGE_TAG

# Run the new container
docker run -d -p 80:80 --name web-app-container \$IMAGE_REPO_URL:\$IMAGE_TAG
"""
                }

                withCredentials([sshUserPrivateKey(
                    credentialsId: env.WEB_APP_HOST_SSH_CREDENTIAL_ID, 
                    keyFileVariable: 'SSH_KEY_PATH', 
                    usernameVariable: 'SSH_USER'
                )]) {
                    
                    // SCP command to transfer the script
                    sh "scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i \"${SSH_KEY_PATH}\" deploy.sh ${SSH_USER}@${env.WEB_APP_HOST_DNS}:/home/${SSH_USER}/deploy.sh"

                    // SSH command to execute the script
                    sh "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i \"${SSH_KEY_PATH}\" ${SSH_USER}@${env.WEB_APP_HOST_DNS} 'bash -lc \"chmod +x /home/${SSH_USER}/deploy.sh && /home/${SSH_USER}/deploy.sh ${IMAGE_TAG}\"'"
                }
            }
        }
    }
}