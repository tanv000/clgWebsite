// -----------------------------------------------------------------------------
// Jenkins Pipeline for CI/CD of abc-college-web-app
// -----------------------------------------------------------------------------
pipeline {
    agent any

    environment {
        // AWS ECR Settings 
        AWS_REGION      = 'ap-south-1' 
        AWS_ACCOUNT_ID  = '708972351530' 
        ECR_REPOSITORY  = 'abc-college-web-app' 
        IMAGE_TAG       = "latest" 
        FULL_IMAGE_NAME = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}" 

        // EC2 Host Settings 
        // These will be set dynamically in the 'Apply Infrastructure' stage
        WEB_APP_HOST_DNS = '' // Will be set dynamically by Terraform (Used for deployment)
        WEB_APP_HOST_IP  = '' // Will be set dynamically by Terraform (For reference)
        WEB_APP_HOST_USER = 'ec2-user' 
        // Credential ID for the SSH Key stored in Jenkins (Username with private key)
        WEB_APP_HOST_SSH_CREDENTIAL_ID = 'WEB_APP_HOST_SSH' 
    }

    stages {
        stage('SCM Checkout') {
            steps {
                echo 'Cloning repository...'
                checkout scm 
            }
        }

        stage('Destroy Previous Infrastructure (Optional)') {
            steps {
                dir('terraform') { 
                    withCredentials([
                        usernamePassword(
                            credentialsId: 'AWS_ECR_CREDENTIALS', 
                            usernameVariable: 'AWS_ACCESS_KEY_ID', 
                            passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                        )
                    ]) {
                        bat 'echo "Attempting to destroy any existing infrastructure..."'
                        // Destroys resources created by this Terraform state
                        bat 'terraform destroy -auto-approve || echo "No infrastructure found or error during destroy. Continuing..."' 
                    }
                }
            }
        }

        stage('Apply Infrastructure (Terraform)') {
            steps {
                dir('terraform') { 
                    withCredentials([
                        usernamePassword(
                            credentialsId: 'AWS_ECR_CREDENTIALS', 
                            usernameVariable: 'AWS_ACCESS_KEY_ID', 
                            passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                        )
                    ]) {
                        script {
                            bat 'echo "Initializing Terraform"'
                            bat 'terraform init' 
                            
                            bat 'echo "Applying Infrastructure"'
                            bat 'terraform apply -auto-approve'

                            // Capture the Public DNS output
                            def publicDns = bat(
                                script: 'terraform output -raw web_app_public_dns', 
                                returnStdout: true
                            ).trim()
                            
                            // Capture the Public IP output
                            def publicIp = bat(
                                script: 'terraform output -raw web_app_public_ip', 
                                returnStdout: true
                            ).trim()
                            
                            // Set the environment variables
                            env.WEB_APP_HOST_DNS = publicDns
                            env.WEB_APP_HOST_IP  = publicIp
                            
                            echo "EC2 Host DNS is now dynamically set to: ${env.WEB_APP_HOST_DNS}"
                            echo "EC2 Host IP is now dynamically set to: ${env.WEB_APP_HOST_IP}"
                        }
                    }
                }
            }
        }

        stage('Docker Build & Push to ECR') {
            steps {
                // Ensure the build uses the files in the workspace root
                bat "docker build -t ${env.FULL_IMAGE_NAME} ."
                
                withCredentials([
                    usernamePassword(
                        credentialsId: 'AWS_ECR_CREDENTIALS', 
                        usernameVariable: 'AWS_ACCESS_KEY_ID', 
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )
                ]) {
                    // Log in to ECR
                    // Uses 'sh' since the AWS CLI command is Linux/Bash syntax, assuming the agent has sh/bash available.
                    sh "aws ecr get-login-password --region ${env.AWS_REGION} | docker login --username AWS --password-stdin ${env.AWS_ACCOUNT_ID}.dkr.ecr.${env.AWS_REGION}.amazonaws.com"

                    // Push the image
                    bat "docker push ${env.FULL_IMAGE_NAME}"
                    echo "Pushed Docker image to ECR: ${env.FULL_IMAGE_NAME}"
                }
            }
        }

        stage('Deploy to EC2') {
            steps {
                echo "Deploying to EC2 host using DNS: ${env.WEB_APP_HOST_DNS}"
                
                // Write the deployment script to a local file
                writeFile file: 'deploy.sh', text: """
                    #!/bin/bash
                    # This script runs on the remote EC2 instance
                    
                    IMAGE_TAG=\$1
                    AWS_REGION=${env.AWS_REGION}
                    AWS_ACCOUNT_ID=${env.AWS_ACCOUNT_ID}
                    ECR_REPOSITORY=${env.ECR_REPOSITORY}
                    
                    FULL_IMAGE_NAME="\$AWS_ACCOUNT_ID.dkr.ecr.\$AWS_REGION.amazonaws.com/\$ECR_REPOSITORY:\$IMAGE_TAG"

                    echo "Stopping and removing existing container..."
                    # Find and stop the running container based on the image name
                    docker stop \$(docker ps -a -q --filter ancestor=\$FULL_IMAGE_NAME) || true
                    # Remove the container
                    docker rm \$(docker ps -a -q --filter ancestor=\$FULL_IMAGE_NAME) || true
                    # Remove the old image
                    docker rmi \$FULL_IMAGE_NAME || true

                    echo "Logging into AWS ECR..."
                    # The IAM Instance Profile on the EC2 instance provides credentials for this command
                    aws ecr get-login-password --region \$AWS_REGION | docker login --username AWS --password-stdin \$AWS_ACCOUNT_ID.dkr.ecr.\$AWS_REGION.amazonaws.com

                    echo "Pulling new image: \$FULL_IMAGE_NAME"
                    docker pull \$FULL_IMAGE_NAME
                    
                    echo "Running new container on port 80..."
                    # -d: run detached, -p: expose EC2 port 80 to container port 80, --name: name the container
                    docker run -d -p 80:80 --name web-app \$FULL_IMAGE_NAME

                    echo "Deployment complete. Check http://${env.WEB_APP_HOST_DNS} or http://${env.WEB_APP_HOST_IP}"
                    """

                withCredentials([sshUserPrivateKey(
                    credentialsId: env.WEB_APP_HOST_SSH_CREDENTIAL_ID, 
                    keyFileVariable: 'SSH_KEY_PATH', 
                    usernameVariable: 'SSH_USER'
                )]) {
                    
                    // SCP command to transfer the script
                    sh "scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i \"${SSH_KEY_PATH}\" deploy.sh ${SSH_USER}@${env.WEB_APP_HOST_DNS}:/home/${SSH_USER}/deploy.sh" 

                    // SSH command to execute the script
                    // 'bash -lc' ensures the shell is a login shell, loading the .bashrc with the correct PATH for docker/aws
                    sh "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i \"${SSH_KEY_PATH}\" ${SSH_USER}@${env.WEB_APP_HOST_DNS} 'bash -lc \"chmod +x /home/${SSH_USER}/deploy.sh && /home/${SSH_USER}/deploy.sh ${IMAGE_TAG}\"'"
                }
            }
        }
    }
}